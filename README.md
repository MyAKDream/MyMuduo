# My_muduo

[TOC]

## 项目名称

仿`Muduo`库的高性能`HTTP`服务器

## 功能模块划分

### server模块

1. 监听连接管理：多监听连接进行管理
2. 通信连接管理：对通信连接进行管理
3. 超时连接管理：对超时连接进行管理

#### Buffer子模块

`Buffer`是一个缓冲区模块

**功能**：实现通信中**用户态层面上的接收缓冲区和发送缓冲区功能**。

**意义**：
1. 防止我们接收到的数据不是一条完整的数据，因此对接受缓冲区进行缓冲
2. 对于客户端响应的数据，在**套接字可写的情况下**进行发送。

**功能设计**：
1. 向缓冲区中添加数据
2. 从缓冲区中取出数据

**实现思想**
1. 缓冲区要用`vector<char>`，`vector<char>`底层起始使用的是一个线性的内存空间

**要素**
1. 默认空间大小
2. 当前读取数据的位置
3. 当前写入数据的位置

**操作**
1. 写入数据：当前写入位置指向哪里，就从哪里开始写入，如果后续剩余空间不够了，考虑整体缓冲去空闲空间是否足够（因为读位置也会向后偏移，前边有可能会有空闲空间）
	1. 足够：将数据移动到起始为止即可
	2. 不够：扩容，从当前写位置开始扩容足够大小

数据一旦写入成功，当前写的位置就要向后偏移。
2. 读取数据：当前的读取位置指向哪里，就从哪里开始读取，前提是有数据可读。**可读数据大小：当前写入位置 - 当前读取位置**

#### Socket子模块

**功能**：对套接字的操作进行封装

**意义**：方便使用

**功能**：
1. 创建套接字
2. 绑定地址信息
3. 开始监听
4. 向服务器发送链接请求
5. 获取新建的链接
6. 数据的接收和发送
7. 关闭套接字
8. 直接创建服务器连接和客户端连接

#### Channel子模块

**功能**：对于一个描述符进行监控事件管理
**意义**：当一个描述符进行监控事件在用户态更容易维护，以及触发后的事件后的操作流程更加清晰。

**功能设计**：
1. 对监控事件的管理：对描述符进行监控，判断描述符是否可读是否可写，解除可读或可写的事件监控。
2. 对监控事件触发后的处理：对于不同事件设置**回调处理函数**，明确触发了某个事件之后应该怎么处理。

#### Connection子模块

**功能**：
1. 对通信连接进行整体管理的一个模块，对一个连接的操作都是通过这个模块进行的。
2. 一个连接有任何事件该怎么处理，都会由`Connection`模块进行处理。

**意义**：这个模块本身说不是一个单独的功能模块，是一个对连接做管理的模块，**增加连接操作的灵活和便捷性**。

**功能设计**：
1. 套接字的管理，能够进行套接字操作
2. 连接事件的管理，可读，可写，挂断，任意。
3. 缓冲区的管理，便于`socket`数据的接收和发送。
4. 协议上下文的管理：记录请求数据的处理过程。

**功能**：
1. 发送数据 —— 给用户提供的发送数据接口，并不是真正的发送接口，而只是把数据放到发送缓冲区，然后启动写事件监控。
2. 关闭连接 —— 给用户提供的关闭连接接口，应该在实际释放链接之前，看看输入输出缓冲区是否有数据待处理。

5. 回调函数设置：
    - 连接建立完成数据时的回调。
    - 连接有新数据接收成功后的回调。
    - 连接关闭时的回调。
    - 产生任何事件进行的回调。

#### Acceptor子模块

**功能**：对监听套接字进行管理。
1. 创建一个套接字
2. 启动读事件监控
3. 事件触发后，获取新链接
4. 为新链接创建`Connection`进行管理（这一步是服务器模块的来进行管理的）务器模块，实现了一个对于新链接描述符处理的函数，将这个函数设置给`Acceptor`模块中的回调函数。

**意义**：
1. 当获取了一个新建连接的描述符之后，需要为这个通信连接，封装一个`Connection`对象，设置各种不同的回调
2. 注意：因为`Accpeter`模块本身不知道连接产生了某个时间应该如何处理，因此获取一个通信连接后`Connection`的封装，以及时间回调的设置都应该由服务器模块来进行。

#### TimerQueue子模块

**功能**：定时任务模块，让一个任务指定在一段时间之后执行
**意义**：组件内部对于非活跃连接，希望在N秒之后被释放

**功能设计**：
1. 添加定时任务
2. 刷新定时任务：希望一个定时任务重新开始计时
3. 取消定时任务


#### Poller子模块

**功能**：对任意的描述符进行`IO`事件监控，是一个对`epoll`进行的封装的一个模块

**意义**：对`epoll`进行封装，让描述符进行事件监控的操作更加简单

**功能接口**：
1. 添加事件监控 —— `Channel`模块。
2. 修改事件监控。
3. 移除事件监控。

#### EventLoop子模块

**功能**：对连接事件监控管理的模块，这个模块其实就是`one thread one loop`中的`loop`，也就是`Reactor`模块。这个模块必然是一个模块对应一个线程。

**意义**：
1. 对于服务器中所以的事件都是由`EventLoop`模块来完成。
2. 每个`Connection`连接，都会绑定一个EventLoop模块和线程，因为外界对于连接的所有操作，都是要放到同一个线程中进行的。

**思想**：
1. 对所有的连接进行事件监控：触发事件之后，调用回调进行处理
2. 对连接的所有操作，都要放到`EventLoop`线程中执行，将任务添加到任务队列中。

**功能设计**：
1. 将任务添加到执行队列。
2. 将定时器事件和刷新。
3. 定时任务的取消。

**实现细节**

监控一个连接，而这个连接一旦就绪，就要进行事件处理，但是如果这个描述符，在多线程中都触发了事件，进行处理，就会存在线程安全的问题。
因此我们需要将一个连接的事件监控，以及连接事件处理，以及其他操作都放在同一个线程进行！

如何保证一个连接的所有操作都在`EventLoop`对应的线程中呢？
> 给`EventLoop`模块中，添加一个任务队列，对连接的所有操作并不直接执行，都进行一次封装，将对连接的所有操作当做任务添加到任务队列中。

**EventLoop处理流程**
1. 在线程中对描述符进行事件监控
2. 有描述符就绪则会对描述符进行事件处理
3. 所有的就绪时间处理完了，这时候再去将任务队列中的所有任务一一执行
4. 我们给任务队列加锁，就可以保证连接操作，都是在一个线程中进行的，不涉及线程安全的问题。

#### LoopThread子模块

**功能**：将EventLoop与Thread整合到一起
**思想**：
1. 创建线程
2. 在线程中实例化EventLoop对象

**功能**：可以向外部返回所实例化的EventLoop

#### LoopThreadPool子模块

针对`LoopThread`设计一个线程池：便于对所有的`LoopThread`进行管理及分配

**功能**：
1. 线程数量可配置（`0`个或多个） 
2. 对所有的线程进行管理，起始就是管理`0`个或多个`LoopThread`对象。
3. 提供线程分配的功能，当主线程获取了一个新链接，需要将新链接挂到从属线程上进行事件监控及处理，假设有0个从属线程，则直接分配给主线程的EventLoop，进行处理。假设有多个从属线程，则采用`RR`轮转思想，进行线程分配（将对于线程的`EventLoop`获取到，设置给对应的`Connection`）

**注意事项**
在服务器中，主从`Reactor`模型时主线程只负责新链接获取，从属线程负责新链接的时间监控及处理，因此当前的线程池，有可能从属线程数量会为0，也就是实现但Reactor服务器，一个线程及复杂获取链接，也负责连接管理。


#### TcpServer子模块

**目的**：对前面所有子模块的整合模块，是提供给用户一个高性能服务器方模块

**管理**：
1. `Accepter`对象，创建一个监听套接字
2. `EventLoop`对象，`baseloop`对象，实现对监听套接字的事件监控
3. `std::unordered_map<uint64_t, PtrConnection> _conns`：实现对所有新建连接的管理
4. `LoopThreadPool`对象，创建一个`Loop`线程池，对新建连接进行事件监控和处理

**功能**：
1. 设置从属线程池的数量。
2. 启动服务器。
3. 设置各种回调函数（连接建立完成、消息、关闭、任意），用户设置给`TcpServer`，`TcpServer`设置给获取的新链接。
4. 是否启动非活跃连接超时销毁功能。
5. 添加定时任务功能。

**流程**
1. 在`TCPserver`中实例化一个`Accepter`对象，以及一个EventLoop对象（baseloop）
2. 将`Acceptor`挂到`baseloop`上进行事件监控
3. 一旦`Acceptor`对象就绪了可读时间 ，则执行读事件回调函数获取新建连接
4. 对新链接，创建一个`Connection`进行管理
5. 连接对于的`Connection`设置功能回调（连接完成回调，消息回调，关闭回调，任意时间回调）
6. 启动`Connection`非活跃连接的超时销毁规则。
7. 将新链接对于的`Connection`挂到`LoopThreadPool`中的从属线程对应的`EventLoop`中进行事件监控。
8. 一旦Connection对应的连接就绪了可读状态，则这时候执行对时间的回调函数，读清楚数据，读取完毕后调用TcpServer设置的消息回调。

### HTTP模块

HTTP协议模块负责对高并发服务器模块进行协议支持，基于提供的协议支持能够更方便的完成指定协议服务器的搭建。

#### Util模块

**功能**：在协议模块中，提供一些零碎的功能。

1. 读取文件内容
2. 向文件写入内容
3. `URL`编码
4. `URL`解码
5. `HTTP`状态码和描述信息
6. 根据文件后缀名获取`mine`

#### HttpResquest模块

**功能：**

1. 存储HTTP请求信息
2. 接收到一个数据，按照HTTP请求格式进行解析，得到各个关键要素放到`Requset`中。
3. 当HTTP的请求分析更加简单

**要素：**
1. URL：资源路径，查询字符串
2. 协议版本
3. 头部字段
4. 正文

**接口**：
1. 头部字段的插入和获取
2. 查询字符串的插入和获取
3. 长连接和短连接的判断
4. 正文长度获取

#### HttpResponse模块

**功能：**
存储HTTP响应信息，进行业务处理的同时，让使用者向Resqonse中填充响应要素，完毕后，让其组织成为HTTP响应格式的数据，发送给客户端。

**要素：**
1. 协议版本
2. 状态响应码
3. 头部字段
4. 正文
5. 重定向信息（是否进行了重定向，重定向的路径）

**接口：**
1. 头部字段的插入、查询、获取。
2. 长连接和短连接的设置与判断。
3. 正文设置。
4. 重定向设置
5. 长短连接判断

#### HttpContext模块



#### HttpServer模块

**功能：**对`HTTP`所有模块的整合

**设计：**
设计一张路由表：
1. 表中记录了针对哪个请求，应该使用哪个函数来进行业务处理的映射关系
2. 当服务器收到了一个请求，就在请求路由表中，查找有没有对应请求的处理函数，如果有，则执行对应的处理函数即可。
什么请求，由用户设定怎么处理这业务。服务器只需要接收数据，解析数据，查找路由表映射关心，执行业务处理函数。

要实现简单的搭建`HTTP`服务器，所需要的要素和提供的功能

**要素：**
1. `GET`请求的路由映射表
2. `POST`请求的路由映射表
3. `PUT`请求的路由映射表
4. `DELETE`请求的路由映射表，路由映射表记录对应的请求方法的请求的处理函数映射关系。
5. 高性能`TCP`服务器，进行连接的IO操作
6. 静态资源的相对根目录，实现静态资源的处理

- 服务器处理流程：
	1. 从`socket`接受数据，放到接受缓冲区
	2. 调用`OnMessage`回调函数进行业务处理
	3. 对请求进行解析，得到了一个HttpRequest结构，包含了所有的请求要素
	4. 进行请求路由查找，找到对应的处理方法。
		1. 静态资源请求 —— 实体文件资源的请求，`html, image...`，将静态资源文件数据读取出来，填充到`HttpResponse`结构中
		2. 功能性请求 —— 在请求路由映射表中查找处理函数，找到了则执行函数。具体的业务处理，并进行`HttpResponse`结构的数据填充
	5. 对静态资源请求/功能性请求处理完毕后，得到了一个填充了响应信息的`HttpResponse`对象，组织`http`格式响应，进行发送。

**接口：**
1. 添加请求——处理函数映射信息
2. 设置静态资源根目录
3. 设置是否超时自动关闭
4. 设置线程池的线程数量
5. 启动服务器


